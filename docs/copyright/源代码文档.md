# 设备数字护照溯源管理系统 源代码文档

**软件名称:** 设备数字护照溯源管理系统
**版本号:** V1.0.0
**著作权人:** [您的公司名称]
**完成日期:** 2026年1月
**开发语言:** TypeScript
**代码行数:** 约50,000行
**文档说明:** 本文档包含软件源代码的前30页和后30页，每页约50行代码

---

# 第一部分：源代码前30页

## 1. 后端入口文件 (apps/api/src/main.ts)

```typescript
import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';
import { AppModule } from './app.module';
import { TransformInterceptor } from './common/interceptors/transform.interceptor';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Global prefix
  app.setGlobalPrefix('api/v1');

  // CORS
  app.enableCors({
    origin: process.env.CORS_ORIGINS?.split(',') || [
      'http://localhost:5173',
      'http://localhost:5174',
      'http://localhost:5175',
      'http://localhost:5176',
      'http://localhost:5177',
      'http://localhost:5178',
      'http://localhost:5179',
      'http://localhost:5180',
    ],
    credentials: true,
  });

  // Validation pipe
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
    }),
  );

  // Transform interceptor - wraps all responses in { success, data, timestamp }
  app.useGlobalInterceptors(new TransformInterceptor());

  // Swagger documentation
  const config = new DocumentBuilder()
    .setTitle('Device Passport API')
    .setDescription('B2B Device Passport Traceability System API')
    .setVersion('1.0')
    .addBearerAuth()
    .addTag('auth', 'Authentication endpoints')
    .addTag('passports', 'Device passport management')
    .addTag('lifecycle', 'Device lifecycle events')
    .addTag('service-orders', 'Service order management')
    .addTag('scan', 'Public scan endpoint')
    .build();

  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api', app, document);

  const port = process.env.API_PORT || 3000;
  await app.listen(port);

  console.log(`Application is running on: http://localhost:${port}`);
  console.log(`Swagger documentation: http://localhost:${port}/api`);
}

bootstrap();
```

## 2. 应用模块 (apps/api/src/app.module.ts)

```typescript
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { ServeStaticModule } from '@nestjs/serve-static';
import { join } from 'path';
import { AuthModule } from './modules/auth/auth.module';
import { UserModule } from './modules/user/user.module';
import { PassportModule } from './modules/passport/passport.module';
import { LifecycleModule } from './modules/lifecycle/lifecycle.module';
import { ServiceOrderModule } from './modules/service-order/service-order.module';
import { ScanModule } from './modules/scan/scan.module';
import { ProductTypeModule } from './modules/product-type/product-type.module';
import { UploadModule } from './modules/upload/upload.module';
import { RegistrationModule } from './modules/registration/registration.module';
import { MarketplaceModule } from './modules/marketplace/marketplace.module';
import { MatchingModule } from './modules/matching/matching.module';
import { InquiryModule } from './modules/inquiry/inquiry.module';
import { SavedModule } from './modules/saved/saved.module';
import databaseConfig from './config/database.config';
import jwtConfig from './config/jwt.config';

@Module({
  imports: [
    // Configuration
    ConfigModule.forRoot({
      isGlobal: true,
      load: [databaseConfig, jwtConfig],
      envFilePath: ['.env.local', '.env'],
    }),

    // Database
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        type: 'postgres',
        host: configService.get('database.host'),
        port: configService.get('database.port'),
        username: configService.get('database.username'),
        password: configService.get('database.password'),
        database: configService.get('database.name'),
        entities: [__dirname + '/**/*.entity{.ts,.js}'],
        synchronize: configService.get('database.synchronize'),
        logging: configService.get('database.logging'),
      }),
      inject: [ConfigService],
    }),

    // Static file serving for uploads
    ServeStaticModule.forRoot({
      rootPath: join(__dirname, '..', 'uploads'),
      serveRoot: '/uploads',
    }),

    // Feature modules
    AuthModule,
    UserModule,
    PassportModule,
    LifecycleModule,
    ServiceOrderModule,
    ScanModule,
    ProductTypeModule,
    UploadModule,
    RegistrationModule,
    MarketplaceModule,
    MatchingModule,
    InquiryModule,
    SavedModule,
  ],
})
export class AppModule {}
```

## 3. 共享枚举定义 (packages/shared/src/enums/index.ts)

```typescript
/**
 * User roles with ascending permission levels
 */
export enum UserRole {
  PUBLIC = 'PUBLIC',
  CUSTOMER = 'CUSTOMER',
  ENGINEER = 'ENGINEER',
  QC_INSPECTOR = 'QC_INSPECTOR',
  OPERATOR = 'OPERATOR',
  ADMIN = 'ADMIN',
}

/**
 * Device lifecycle status
 */
export enum DeviceStatus {
  CREATED = 'CREATED',
  PROCURED = 'PROCURED',
  IN_QC = 'IN_QC',
  QC_PASSED = 'QC_PASSED',
  QC_FAILED = 'QC_FAILED',
  IN_ASSEMBLY = 'IN_ASSEMBLY',
  IN_TESTING = 'IN_TESTING',
  TEST_PASSED = 'TEST_PASSED',
  TEST_FAILED = 'TEST_FAILED',
  PACKAGED = 'PACKAGED',
  IN_TRANSIT = 'IN_TRANSIT',
  DELIVERED = 'DELIVERED',
  IN_SERVICE = 'IN_SERVICE',
  MAINTENANCE = 'MAINTENANCE',
  RETIRED = 'RETIRED',
}

/**
 * Product type codes for passport generation
 */
export enum ProductLine {
  PF = 'PF',   // Packaging Filling
  QI = 'QI',   // Quality Inspection
  MP = 'MP',   // Metal Processing
  PP = 'PP',   // Plastics Processing
  HL = 'HL',   // Hospital Lab
  ET = 'ET',   // Education Training
  WL = 'WL',   // Warehouse Logistics
  IP = 'IP',   // Industrial Parts
  CS = 'CS',   // Custom Solutions
}

// Alias for clearer naming
export type ProductType = ProductLine;
export const ProductType = ProductLine;

/**
 * Service order status
 */
export enum ServiceOrderStatus {
  PENDING = 'PENDING',
  ASSIGNED = 'ASSIGNED',
  IN_PROGRESS = 'IN_PROGRESS',
  ON_HOLD = 'ON_HOLD',
  COMPLETED = 'COMPLETED',
  CANCELLED = 'CANCELLED',
}

/**
 * Service types
 */
export enum ServiceType {
  INSTALLATION = 'INSTALLATION',
  REPAIR = 'REPAIR',
  MAINTENANCE = 'MAINTENANCE',
  INSPECTION = 'INSPECTION',
  UPGRADE = 'UPGRADE',
  CONSULTATION = 'CONSULTATION',
}

/**
 * Lifecycle event types
 */
export enum LifecycleEventType {
  STATUS_CHANGE = 'STATUS_CHANGE',
  LOCATION_CHANGE = 'LOCATION_CHANGE',
  OWNERSHIP_TRANSFER = 'OWNERSHIP_TRANSFER',
  SERVICE_PERFORMED = 'SERVICE_PERFORMED',
  DOCUMENT_ATTACHED = 'DOCUMENT_ATTACHED',
  NOTE_ADDED = 'NOTE_ADDED',
  QC_INSPECTION = 'QC_INSPECTION',
  TEST_RESULT = 'TEST_RESULT',
}

/**
 * Country/Origin codes (ISO 3166-1 alpha-2)
 */
export enum OriginCode {
  CN = 'CN', // China
  DE = 'DE', // Germany
  JP = 'JP', // Japan
  US = 'US', // United States
  KR = 'KR', // South Korea
  TW = 'TW', // Taiwan
  IT = 'IT', // Italy
  FR = 'FR', // France
  GB = 'GB', // United Kingdom
  CH = 'CH', // Switzerland
  VN = 'VN', // Vietnam
  OTHER = 'OTHER', // Other (custom)
}

/**
 * Valid status transitions map
 */
export const VALID_STATUS_TRANSITIONS: Record<DeviceStatus, DeviceStatus[]> = {
  [DeviceStatus.CREATED]: [DeviceStatus.PROCURED],
  [DeviceStatus.PROCURED]: [DeviceStatus.IN_QC],
  [DeviceStatus.IN_QC]: [DeviceStatus.QC_PASSED, DeviceStatus.QC_FAILED],
  [DeviceStatus.QC_PASSED]: [DeviceStatus.IN_ASSEMBLY],
  [DeviceStatus.QC_FAILED]: [DeviceStatus.IN_QC, DeviceStatus.RETIRED],
  [DeviceStatus.IN_ASSEMBLY]: [DeviceStatus.IN_TESTING],
  [DeviceStatus.IN_TESTING]: [DeviceStatus.TEST_PASSED, DeviceStatus.TEST_FAILED],
  [DeviceStatus.TEST_PASSED]: [DeviceStatus.PACKAGED],
  [DeviceStatus.TEST_FAILED]: [DeviceStatus.IN_ASSEMBLY, DeviceStatus.RETIRED],
  [DeviceStatus.PACKAGED]: [DeviceStatus.IN_TRANSIT],
  [DeviceStatus.IN_TRANSIT]: [DeviceStatus.DELIVERED],
  [DeviceStatus.DELIVERED]: [DeviceStatus.IN_SERVICE],
  [DeviceStatus.IN_SERVICE]: [DeviceStatus.MAINTENANCE, DeviceStatus.RETIRED],
  [DeviceStatus.MAINTENANCE]: [DeviceStatus.IN_SERVICE, DeviceStatus.RETIRED],
  [DeviceStatus.RETIRED]: [],
};

/**
 * Role permission levels (higher number = more permissions)
 */
export const ROLE_PERMISSION_LEVELS: Record<UserRole, number> = {
  [UserRole.PUBLIC]: 0,
  [UserRole.CUSTOMER]: 1,
  [UserRole.ENGINEER]: 2,
  [UserRole.QC_INSPECTOR]: 3,
  [UserRole.OPERATOR]: 4,
  [UserRole.ADMIN]: 5,
};

/**
 * Product type display names
 */
export const PRODUCT_TYPE_NAMES: Record<ProductLine, string> = {
  [ProductLine.PF]: 'Packaging Filling',
  [ProductLine.QI]: 'Quality Inspection',
  [ProductLine.MP]: 'Metal Processing',
  [ProductLine.PP]: 'Plastics Processing',
  [ProductLine.HL]: 'Hospital Lab',
  [ProductLine.ET]: 'Education Training',
  [ProductLine.WL]: 'Warehouse Logistics',
  [ProductLine.IP]: 'Industrial Parts',
  [ProductLine.CS]: 'Custom Solutions',
};

/**
 * Registration type - Company or Individual Expert
 */
export enum RegistrationType {
  COMPANY = 'COMPANY',
  INDIVIDUAL_EXPERT = 'INDIVIDUAL_EXPERT',
}

/**
 * Company role - can be Supplier, Buyer, or both
 */
export enum CompanyRole {
  SUPPLIER = 'SUPPLIER',
  BUYER = 'BUYER',
}

/**
 * Expert type - Technical or Business
 */
export enum ExpertType {
  TECHNICAL = 'TECHNICAL',
  BUSINESS = 'BUSINESS',
}

/**
 * Registration approval status
 */
export enum RegistrationStatus {
  PENDING = 'PENDING',
  UNDER_REVIEW = 'UNDER_REVIEW',
  APPROVED = 'APPROVED',
  REJECTED = 'REJECTED',
  SUSPENDED = 'SUSPENDED',
}

/**
 * Marketplace product listing status
 */
export enum MarketplaceListingStatus {
  DRAFT = 'DRAFT',
  PENDING_REVIEW = 'PENDING_REVIEW',
  ACTIVE = 'ACTIVE',
  PAUSED = 'PAUSED',
  EXPIRED = 'EXPIRED',
  REMOVED = 'REMOVED',
}

/**
 * RFQ (Request for Quotation) status
 */
export enum RFQStatus {
  DRAFT = 'DRAFT',
  OPEN = 'OPEN',
  CLOSED = 'CLOSED',
  FULFILLED = 'FULFILLED',
  CANCELLED = 'CANCELLED',
  EXPIRED = 'EXPIRED',
}

/**
 * Match type - direction of the match
 */
export enum MatchType {
  PRODUCT_TO_BUYER = 'PRODUCT_TO_BUYER',
  REQUIREMENT_TO_SUPPLIER = 'REQUIREMENT_TO_SUPPLIER',
}

/**
 * Match status - user interaction state
 */
export enum MatchStatus {
  NEW = 'NEW',
  VIEWED = 'VIEWED',
  CONTACTED = 'CONTACTED',
  DISMISSED = 'DISMISSED',
}

/**
 * Inquiry status
 */
export enum InquiryStatus {
  PENDING = 'PENDING',
  RESPONDED = 'RESPONDED',
  NEGOTIATING = 'NEGOTIATING',
  ACCEPTED = 'ACCEPTED',
  REJECTED = 'REJECTED',
  EXPIRED = 'EXPIRED',
}

/**
 * Inquiry message type
 */
export enum InquiryMessageType {
  MESSAGE = 'MESSAGE',
  QUOTE = 'QUOTE',
  COUNTER_OFFER = 'COUNTER_OFFER',
  ACCEPTANCE = 'ACCEPTANCE',
  REJECTION = 'REJECTION',
  SYSTEM = 'SYSTEM',
}
```

## 4. 设备护照实体 (apps/api/src/database/entities/device-passport.entity.ts)

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  JoinColumn,
  OneToMany,
} from 'typeorm';
import { DeviceStatus, ProductLine, OriginCode } from '@device-passport/shared';
import { Organization } from './organization.entity';
import { User } from './user.entity';
import { LifecycleEvent } from './lifecycle-event.entity';

@Entity('device_passports')
export class DevicePassport {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ name: 'passport_code', unique: true })
  passportCode: string;

  @Column({
    name: 'product_line',
    type: 'enum',
    enum: ProductLine,
  })
  productLine: ProductLine;

  @Column({
    name: 'origin_code',
    type: 'enum',
    enum: OriginCode,
  })
  originCode: OriginCode;

  @Column({ name: 'custom_origin_code', length: 2, nullable: true })
  customOriginCode: string;

  @Column({
    type: 'enum',
    enum: DeviceStatus,
    default: DeviceStatus.CREATED,
  })
  status: DeviceStatus;

  @Column({ name: 'device_name' })
  deviceName: string;

  @Column({ name: 'device_model' })
  deviceModel: string;

  @Column()
  manufacturer: string;

  @Column({ name: 'manufacturer_part_number', nullable: true })
  manufacturerPartNumber: string;

  @Column({ name: 'serial_number', nullable: true })
  serialNumber: string;

  @Column({ type: 'jsonb', nullable: true })
  specifications: Record<string, unknown>;

  @Column({ name: 'manufacture_date', type: 'date', nullable: true })
  manufactureDate: Date;

  @Column({ name: 'warranty_expiry_date', type: 'date', nullable: true })
  warrantyExpiryDate: Date;

  @Column({ name: 'supplier_id', nullable: true })
  supplierId: string;

  @ManyToOne(() => Organization, { nullable: true })
  @JoinColumn({ name: 'supplier_id' })
  supplier: Organization;

  @Column({ name: 'customer_id', nullable: true })
  customerId: string;

  @ManyToOne(() => Organization, { nullable: true })
  @JoinColumn({ name: 'customer_id' })
  customer: Organization;

  @Column({ name: 'current_location', nullable: true })
  currentLocation: string;

  @Column({ name: 'location_lat', type: 'decimal', precision: 10, scale: 7, nullable: true })
  locationLat: number;

  @Column({ name: 'location_lng', type: 'decimal', precision: 10, scale: 7, nullable: true })
  locationLng: number;

  @Column({ name: 'location_updated_at', type: 'timestamp', nullable: true })
  locationUpdatedAt: Date;

  // Buyer information fields
  @Column({ name: 'buyer_company', nullable: true })
  buyerCompany: string;

  @Column({ name: 'buyer_contact', nullable: true })
  buyerContact: string;

  @Column({ name: 'buyer_phone', nullable: true })
  buyerPhone: string;

  @Column({ name: 'buyer_country', nullable: true })
  buyerCountry: string;

  @Column({ name: 'buyer_address', nullable: true })
  buyerAddress: string;

  @Column({ name: 'blockchain_hash', nullable: true })
  blockchainHash: string;

  @Column({ name: 'created_by' })
  createdBy: string;

  @ManyToOne(() => User)
  @JoinColumn({ name: 'created_by' })
  creator: User;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;

  @OneToMany(() => LifecycleEvent, (event) => event.passport)
  lifecycleEvents: LifecycleEvent[];
}
```

## 5. 用户实体 (apps/api/src/database/entities/user.entity.ts)

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  JoinColumn,
} from 'typeorm';
import { Exclude } from 'class-transformer';
import { UserRole } from '@device-passport/shared';
import { Organization } from './organization.entity';

@Entity('users')
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  email: string;

  @Column({ select: false })
  @Exclude()
  password: string;

  @Column()
  name: string;

  @Column({
    type: 'enum',
    enum: UserRole,
    default: UserRole.CUSTOMER,
  })
  role: UserRole;

  @Column({ name: 'organization_id', nullable: true })
  organizationId: string;

  @ManyToOne(() => Organization, { nullable: true })
  @JoinColumn({ name: 'organization_id' })
  organization: Organization;

  @Column({ name: 'is_active', default: true })
  isActive: boolean;

  @Column({ name: 'last_login_at', nullable: true })
  lastLoginAt: Date;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;
}
```

## 6. 组织实体 (apps/api/src/database/entities/organization.entity.ts)

```typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
} from 'typeorm';
import { OrganizationType } from '@device-passport/shared';

@Entity('organizations')
export class Organization {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  name: string;

  @Column({ length: 3, unique: true })
  code: string;

  @Column({
    type: 'enum',
    enum: OrganizationType,
    default: OrganizationType.CUSTOMER,
  })
  type: OrganizationType;

  @Column({ nullable: true })
  address: string;

  @Column({ nullable: true })
  city: string;

  @Column({ nullable: true })
  country: string;

  @Column({ nullable: true })
  phone: string;

  @Column({ nullable: true })
  email: string;

  @Column({ nullable: true })
  website: string;

  @Column({ name: 'contact_person', nullable: true })
  contactPerson: string;

  @Column({ name: 'is_active', default: true })
  isActive: boolean;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;
}
```

## 7. 认证服务 (apps/api/src/modules/auth/auth.service.ts)

```typescript
import {
  Injectable,
  UnauthorizedException,
  ConflictException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import * as bcrypt from 'bcrypt';
import { User } from '../../database/entities';
import { LoginDto, RegisterDto } from './dto';
import { TokenPayload, AuthResponse, UserRole } from '@device-passport/shared';

@Injectable()
export class AuthService {
  constructor(
    @InjectRepository(User)
    private userRepository: Repository<User>,
    private jwtService: JwtService,
  ) {}

  async login(loginDto: LoginDto): Promise<AuthResponse> {
    const { email, password } = loginDto;

    const user = await this.userRepository
      .createQueryBuilder('user')
      .addSelect('user.password')
      .where('user.email = :email', { email: email.toLowerCase() })
      .getOne();

    if (!user || !user.isActive) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      throw new UnauthorizedException('Invalid credentials');
    }

    // Update last login
    await this.userRepository.update(user.id, { lastLoginAt: new Date() });

    return this.generateTokens(user);
  }

  async register(registerDto: RegisterDto): Promise<AuthResponse> {
    const { email, password, name, organizationId } = registerDto;

    // Check if user exists
    const existingUser = await this.userRepository.findOne({
      where: { email: email.toLowerCase() },
    });

    if (existingUser) {
      throw new ConflictException('User with this email already exists');
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create user
    const user = this.userRepository.create({
      email: email.toLowerCase(),
      password: hashedPassword,
      name,
      role: UserRole.CUSTOMER,
      organizationId,
    });

    await this.userRepository.save(user);

    return this.generateTokens(user);
  }

  async refreshToken(refreshToken: string): Promise<AuthResponse> {
    try {
      const payload = this.jwtService.verify<TokenPayload>(refreshToken);
      const user = await this.userRepository.findOne({
        where: { id: payload.sub },
      });

      if (!user || !user.isActive) {
        throw new UnauthorizedException('Invalid token');
      }

      return this.generateTokens(user);
    } catch {
      throw new UnauthorizedException('Invalid token');
    }
  }

  async validateUser(userId: string): Promise<User | null> {
    return this.userRepository.findOne({
      where: { id: userId, isActive: true },
    });
  }

  private generateTokens(user: User): AuthResponse {
    const payload: TokenPayload = {
      sub: user.id,
      email: user.email,
      role: user.role,
      organizationId: user.organizationId,
    };

    const accessToken = this.jwtService.sign(payload);
    const refreshToken = this.jwtService.sign(payload, {
      expiresIn: '30d',
    });

    const { password, ...userWithoutPassword } = user;

    return {
      user: userWithoutPassword as Omit<User, 'password'>,
      accessToken,
      refreshToken,
      expiresIn: 7 * 24 * 60 * 60, // 7 days in seconds
    };
  }
}
```

## 8. 护照服务 (apps/api/src/modules/passport/passport.service.ts)

```typescript
import {
  Injectable,
  NotFoundException,
  BadRequestException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Like, Between } from 'typeorm';
import * as QRCode from 'qrcode';
import {
  DeviceStatus,
  VALID_STATUS_TRANSITIONS,
  LifecycleEventType,
  PassportQueryFilters,
  PaginatedResponse,
  PassportListItem,
  generateQRCodeContent,
} from '@device-passport/shared';
import { DevicePassport, User, Organization } from '../../database/entities';
import { CreatePassportDto, UpdatePassportDto, UpdateStatusDto } from './dto';
import { PassportCodeService } from './passport-code.service';
import { LifecycleService } from '../lifecycle/lifecycle.service';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class PassportService {
  private baseUrl: string;

  constructor(
    @InjectRepository(DevicePassport)
    private passportRepository: Repository<DevicePassport>,
    @InjectRepository(User)
    private userRepository: Repository<User>,
    @InjectRepository(Organization)
    private organizationRepository: Repository<Organization>,
    private passportCodeService: PassportCodeService,
    private lifecycleService: LifecycleService,
    private configService: ConfigService,
  ) {
    this.baseUrl = this.configService.get('VITE_API_URL') || 'http://localhost:3000';
  }

  async findAll(filters: PassportQueryFilters): Promise<PaginatedResponse<PassportListItem>> {
    const {
      search,
      productLine,
      status,
      supplierId,
      customerId,
      fromDate,
      toDate,
      page = 1,
      limit = 20,
      sortBy = 'createdAt',
      sortOrder = 'DESC',
    } = filters;

    const queryBuilder = this.passportRepository.createQueryBuilder('passport');

    // Apply filters
    if (search) {
      queryBuilder.andWhere(
        '(passport.passportCode LIKE :search OR passport.deviceName LIKE :search)',
        { search: `%${search}%` },
      );
    }

    if (productLine) {
      queryBuilder.andWhere('passport.productLine = :productLine', { productLine });
    }

    if (status) {
      queryBuilder.andWhere('passport.status = :status', { status });
    }

    // Apply sorting
    queryBuilder.orderBy(`passport.${sortBy}`, sortOrder);

    // Apply pagination
    const skip = (page - 1) * limit;
    queryBuilder.skip(skip).take(limit);

    // Execute query
    const [data, total] = await queryBuilder.getManyAndCount();

    return {
      data: data.map((p) => ({
        id: p.id,
        passportCode: p.passportCode,
        deviceName: p.deviceName,
        deviceModel: p.deviceModel,
        manufacturer: p.manufacturer,
        productLine: p.productLine,
        status: p.status,
        currentLocation: p.currentLocation,
        createdAt: p.createdAt,
      })),
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
      },
    };
  }

  async findById(id: string): Promise<DevicePassport> {
    const passport = await this.passportRepository.findOne({
      where: { id },
      relations: ['supplier', 'customer', 'creator', 'updater'],
    });

    if (!passport) {
      throw new NotFoundException('Device passport not found');
    }

    return passport;
  }

  async create(
    createPassportDto: CreatePassportDto,
    userId: string,
  ): Promise<DevicePassport> {
    const { productLine, originCode, supplierId, ...rest } = createPassportDto;

    // Look up supplier code if supplierId is provided
    let supplierCode: string | undefined;
    if (supplierId) {
      const supplier = await this.organizationRepository.findOne({
        where: { id: supplierId },
      });
      if (supplier) {
        supplierCode = supplier.code;
      }
    }

    // Generate passport code
    const passportCode = await this.passportCodeService.generateCode(
      productLine,
      originCode,
      supplierCode,
    );

    // Create passport
    const passport = this.passportRepository.create({
      ...rest,
      supplierId,
      passportCode,
      productLine,
      originCode,
      status: DeviceStatus.CREATED,
      createdBy: userId,
      updatedBy: userId,
    });

    const savedPassport = await this.passportRepository.save(passport);

    // Create initial lifecycle event
    const user = await this.userRepository.findOne({ where: { id: userId } });
    await this.lifecycleService.create({
      passportId: savedPassport.id,
      eventType: LifecycleEventType.STATUS_CHANGE,
      newStatus: DeviceStatus.CREATED,
      description: 'Device passport created',
    }, userId, user?.name || 'System', user?.role || 'SYSTEM');

    return savedPassport;
  }

  async updateStatus(
    id: string,
    updateStatusDto: UpdateStatusDto,
    userId: string,
  ): Promise<DevicePassport> {
    const passport = await this.findById(id);
    const { status: newStatus, note, location } = updateStatusDto;

    // Validate status transition
    const validTransitions = VALID_STATUS_TRANSITIONS[passport.status];
    if (!validTransitions.includes(newStatus)) {
      throw new BadRequestException(
        `Invalid status transition from ${passport.status} to ${newStatus}`,
      );
    }

    const previousStatus = passport.status;
    const previousLocation = passport.currentLocation;

    // Update passport
    passport.status = newStatus;
    if (location) {
      passport.currentLocation = location;
    }
    passport.updatedBy = userId;

    const updatedPassport = await this.passportRepository.save(passport);

    // Create lifecycle event
    const user = await this.userRepository.findOne({ where: { id: userId } });
    await this.lifecycleService.create({
      passportId: id,
      eventType: LifecycleEventType.STATUS_CHANGE,
      previousStatus,
      newStatus,
      previousLocation,
      newLocation: location,
      description: `Status changed from ${previousStatus} to ${newStatus}`,
      note,
    }, userId, user?.name || 'System', user?.role || 'SYSTEM');

    return updatedPassport;
  }

  async generateQRCode(id: string): Promise<string> {
    const passport = await this.findById(id);
    const content = generateQRCodeContent(passport.passportCode, this.baseUrl);

    // Generate QR code as data URL
    return QRCode.toDataURL(content, {
      errorCorrectionLevel: 'H',
      type: 'image/png',
      margin: 2,
      width: 256,
    });
  }
}
```

---

# 第二部分：源代码后30页

## 9. 智能匹配服务 (apps/api/src/modules/matching/matching.service.ts)

```typescript
import { Injectable, NotFoundException, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, In, Not } from 'typeorm';
import {
  MatchResult,
  MarketplaceProduct,
  BuyerRequirement,
  Organization,
} from '../../database/entities';
import { ScoreBreakdown } from '../../database/entities/match-result.entity';
import {
  MatchType,
  MatchStatus,
  MarketplaceListingStatus,
  RFQStatus,
} from '@device-passport/shared';

// Scoring weights (total 100)
const SCORING_WEIGHTS = {
  locationProximity: 25,   // Highest priority for B2B local trading
  categoryMatch: 20,
  hsCodeMatch: 20,
  priceRangeMatch: 15,
  textSimilarity: 10,
  frequencyMatch: 10,
};

// Distance scoring thresholds
const DISTANCE_SCORES = [
  { maxKm: 50, score: 25 },
  { maxKm: 100, score: 22 },
  { maxKm: 300, score: 18 },
  { maxKm: 500, score: 14 },
  { maxKm: 1000, score: 10 },
  { maxKm: Infinity, score: 5 },
];

// Minimum score to create a match
const MIN_MATCH_SCORE = 50;

@Injectable()
export class MatchingService {
  private readonly logger = new Logger(MatchingService.name);

  constructor(
    @InjectRepository(MatchResult)
    private readonly matchRepository: Repository<MatchResult>,
    @InjectRepository(MarketplaceProduct)
    private readonly productRepository: Repository<MarketplaceProduct>,
    @InjectRepository(BuyerRequirement)
    private readonly requirementRepository: Repository<BuyerRequirement>,
    @InjectRepository(Organization)
    private readonly organizationRepository: Repository<Organization>,
  ) {}

  /**
   * Match a new product against all open requirements
   */
  async matchProductToRequirements(productId: string): Promise<MatchResult[]> {
    const product = await this.productRepository.findOne({
      where: { id: productId, status: MarketplaceListingStatus.ACTIVE },
      relations: ['organization'],
    });

    if (!product) {
      this.logger.warn(`Product ${productId} not found or not active`);
      return [];
    }

    // Get all open requirements
    const requirements = await this.requirementRepository.find({
      where: { status: RFQStatus.OPEN, isPublic: true },
      relations: ['organization'],
    });

    const matches: MatchResult[] = [];

    for (const requirement of requirements) {
      // Skip if same organization
      if (requirement.organizationId === product.organizationId) continue;

      // Check if match already exists
      const existingMatch = await this.matchRepository.findOne({
        where: {
          marketplaceProductId: product.id,
          buyerRequirementId: requirement.id,
        },
      });

      if (existingMatch) continue;

      const score = this.calculateMatchScore(product, requirement);

      if (score.totalScore >= MIN_MATCH_SCORE) {
        const match = this.matchRepository.create({
          matchType: MatchType.PRODUCT_TO_BUYER,
          marketplaceProductId: product.id,
          supplierOrgId: product.organizationId,
          buyerRequirementId: requirement.id,
          buyerOrgId: requirement.organizationId,
          totalScore: score.totalScore,
          scoreBreakdown: score.breakdown,
          distanceKm: score.distanceKm,
          status: MatchStatus.NEW,
        });

        const saved = await this.matchRepository.save(match);
        matches.push(saved);
      }
    }

    return matches;
  }

  /**
   * Calculate match score between product and requirement
   */
  private calculateMatchScore(
    product: MarketplaceProduct,
    requirement: BuyerRequirement,
  ): { totalScore: number; breakdown: ScoreBreakdown; distanceKm: number | null } {
    const breakdown: ScoreBreakdown = {
      categoryMatch: 0,
      hsCodeMatch: 0,
      priceRangeMatch: 0,
      locationProximity: 0,
      textSimilarity: 0,
      frequencyMatch: 0,
    };

    let distanceKm: number | null = null;

    // 1. Category Match (20 points)
    if (product.productCategory && requirement.productCategory) {
      if (product.productCategory === requirement.productCategory) {
        breakdown.categoryMatch = SCORING_WEIGHTS.categoryMatch;
      }
    }

    // 2. HS Code Match (20 points)
    if (product.hsCode && requirement.hsCode) {
      const productHs = product.hsCode.replace(/\D/g, '');
      const reqHs = requirement.hsCode.replace(/\D/g, '');

      if (productHs.substring(0, 6) === reqHs.substring(0, 6)) {
        breakdown.hsCodeMatch = 20;
      } else if (productHs.substring(0, 4) === reqHs.substring(0, 4)) {
        breakdown.hsCodeMatch = 15;
      } else if (productHs.substring(0, 2) === reqHs.substring(0, 2)) {
        breakdown.hsCodeMatch = 10;
      }
    }

    // 3. Price Range Match (15 points)
    if (product.showPrice && product.minPrice && requirement.budgetMax) {
      const productPrice = Number(product.minPrice);
      const budgetMax = Number(requirement.budgetMax);

      if (productPrice <= budgetMax) {
        breakdown.priceRangeMatch = SCORING_WEIGHTS.priceRangeMatch;
      }
    }

    // 4. Location Proximity (25 points - highest weight)
    if (
      product.locationLat && product.locationLng &&
      requirement.buyerLocationLat && requirement.buyerLocationLng
    ) {
      distanceKm = this.calculateDistance(
        Number(product.locationLat),
        Number(product.locationLng),
        Number(requirement.buyerLocationLat),
        Number(requirement.buyerLocationLng),
      );

      for (const tier of DISTANCE_SCORES) {
        if (distanceKm <= tier.maxKm) {
          breakdown.locationProximity = tier.score;
          break;
        }
      }
    }

    // 5. Text Similarity (10 points)
    if (product.description && requirement.description) {
      const productWords = this.extractKeywords(product.description);
      const reqWords = this.extractKeywords(requirement.description);

      const common = productWords.filter((w) => reqWords.includes(w));
      const similarity = common.length / Math.max(productWords.length, reqWords.length, 1);
      breakdown.textSimilarity = Math.round(similarity * SCORING_WEIGHTS.textSimilarity);
    }

    breakdown.frequencyMatch = 5; // Default partial score

    const totalScore =
      breakdown.categoryMatch +
      breakdown.hsCodeMatch +
      breakdown.priceRangeMatch +
      breakdown.locationProximity +
      breakdown.textSimilarity +
      breakdown.frequencyMatch;

    return { totalScore, breakdown, distanceKm };
  }

  /**
   * Haversine formula to calculate distance between two points
   */
  private calculateDistance(
    lat1: number,
    lng1: number,
    lat2: number,
    lng2: number,
  ): number {
    const R = 6371; // Earth radius in km
    const dLat = this.toRad(lat2 - lat1);
    const dLng = this.toRad(lng2 - lng1);
    const a =
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(this.toRad(lat1)) *
        Math.cos(this.toRad(lat2)) *
        Math.sin(dLng / 2) *
        Math.sin(dLng / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  private toRad(deg: number): number {
    return deg * (Math.PI / 180);
  }

  private extractKeywords(text: string): string[] {
    const stopWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for'];
    return text
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, '')
      .split(/\s+/)
      .filter((w) => w.length > 2 && !stopWords.includes(w));
  }

  /**
   * Get match recommendations for a user/organization
   */
  async getRecommendations(
    organizationId: string,
    role: 'supplier' | 'buyer',
    limit = 20,
  ): Promise<MatchResult[]> {
    const where: any = {};

    if (role === 'supplier') {
      where.supplierOrgId = organizationId;
    } else {
      where.buyerOrgId = organizationId;
    }

    where.status = In([MatchStatus.NEW, MatchStatus.VIEWED]);

    return this.matchRepository.find({
      where,
      relations: ['marketplaceProduct', 'buyerRequirement'],
      order: { totalScore: 'DESC', createdAt: 'DESC' },
      take: limit,
    });
  }
}
```

## 10. 询盘服务 (apps/api/src/modules/inquiry/inquiry.service.ts)

```typescript
import {
  Injectable,
  NotFoundException,
  BadRequestException,
  ForbiddenException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, In, Like } from 'typeorm';
import {
  Inquiry,
  InquiryMessage,
  MarketplaceProduct,
  BuyerRequirement,
  Organization,
} from '../../database/entities';
import { CreateInquiryDto, CreateMessageDto, UpdateInquiryStatusDto } from './dto';
import { InquiryStatus, InquiryMessageType } from '@device-passport/shared';

@Injectable()
export class InquiryService {
  constructor(
    @InjectRepository(Inquiry)
    private readonly inquiryRepository: Repository<Inquiry>,
    @InjectRepository(InquiryMessage)
    private readonly messageRepository: Repository<InquiryMessage>,
    @InjectRepository(MarketplaceProduct)
    private readonly productRepository: Repository<MarketplaceProduct>,
    @InjectRepository(BuyerRequirement)
    private readonly requirementRepository: Repository<BuyerRequirement>,
    @InjectRepository(Organization)
    private readonly organizationRepository: Repository<Organization>,
  ) {}

  /**
   * Create a new inquiry
   */
  async createInquiry(
    buyerOrgId: string,
    userId: string,
    dto: CreateInquiryDto,
  ): Promise<Inquiry> {
    // Validate supplier organization
    const supplierOrg = await this.organizationRepository.findOne({
      where: { id: dto.supplierOrgId },
    });
    if (!supplierOrg) {
      throw new NotFoundException('Supplier organization not found');
    }

    // Can't send inquiry to yourself
    if (dto.supplierOrgId === buyerOrgId) {
      throw new BadRequestException('Cannot send inquiry to your own organization');
    }

    // Generate inquiry code
    const inquiryCode = await this.generateInquiryCode();

    const inquiry = this.inquiryRepository.create({
      inquiryCode,
      marketplaceProductId: dto.marketplaceProductId,
      buyerRequirementId: dto.buyerRequirementId,
      matchResultId: dto.matchResultId,
      buyerOrgId,
      supplierOrgId: dto.supplierOrgId,
      initiatedByUserId: userId,
      subject: dto.subject,
      message: dto.message,
      quantity: dto.quantity,
      targetPrice: dto.targetPrice,
      targetCurrency: dto.targetCurrency || 'USD',
      requiredDeliveryDate: dto.requiredDeliveryDate
        ? new Date(dto.requiredDeliveryDate)
        : null,
      status: InquiryStatus.PENDING,
    });

    const savedInquiry = await this.inquiryRepository.save(inquiry);

    // Create initial message if content provided
    if (dto.message) {
      const initialMessage = this.messageRepository.create({
        inquiryId: savedInquiry.id,
        senderUserId: userId,
        senderOrgId: buyerOrgId,
        messageType: InquiryMessageType.MESSAGE,
        content: dto.message,
      });
      await this.messageRepository.save(initialMessage);
    }

    return this.getInquiryById(savedInquiry.id);
  }

  /**
   * Get inquiry by ID with messages
   */
  async getInquiryById(id: string): Promise<Inquiry> {
    const inquiry = await this.inquiryRepository.findOne({
      where: { id },
      relations: [
        'buyerOrg',
        'supplierOrg',
        'marketplaceProduct',
        'buyerRequirement',
        'initiatedByUser',
        'messages',
      ],
    });

    if (!inquiry) {
      throw new NotFoundException('Inquiry not found');
    }

    inquiry.messages?.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());

    return inquiry;
  }

  /**
   * Send a message in an inquiry
   */
  async sendMessage(
    inquiryId: string,
    userId: string,
    organizationId: string,
    dto: CreateMessageDto,
  ): Promise<InquiryMessage> {
    const inquiry = await this.getInquiryWithAccess(inquiryId, organizationId);

    // Check if inquiry is still active
    if ([InquiryStatus.ACCEPTED, InquiryStatus.REJECTED, InquiryStatus.EXPIRED].includes(inquiry.status)) {
      throw new BadRequestException('Cannot send messages to a closed inquiry');
    }

    const message = this.messageRepository.create({
      inquiryId,
      senderUserId: userId,
      senderOrgId: organizationId,
      messageType: dto.messageType,
      content: dto.content,
      quotePrice: dto.quotePrice,
      quoteCurrency: dto.quoteCurrency,
      quoteValidUntil: dto.quoteValidUntil ? new Date(dto.quoteValidUntil) : null,
      quotedLeadTimeDays: dto.quotedLeadTimeDays,
    });

    const savedMessage = await this.messageRepository.save(message);

    // Update inquiry status based on message type
    if (dto.messageType === InquiryMessageType.QUOTE && inquiry.status === InquiryStatus.PENDING) {
      await this.inquiryRepository.update(inquiryId, {
        status: InquiryStatus.RESPONDED,
        respondedAt: new Date(),
      });
    } else if (dto.messageType === InquiryMessageType.ACCEPTANCE) {
      await this.inquiryRepository.update(inquiryId, {
        status: InquiryStatus.ACCEPTED,
        closedAt: new Date(),
      });
    }

    return savedMessage;
  }

  private async generateInquiryCode(): Promise<string> {
    const year = new Date().getFullYear();
    const prefix = `INQ-${year}-`;

    const lastInquiry = await this.inquiryRepository.findOne({
      where: { inquiryCode: Like(`${prefix}%`) },
      order: { inquiryCode: 'DESC' },
    });

    let nextSeq = 1;
    if (lastInquiry && lastInquiry.inquiryCode) {
      const lastSeq = parseInt(lastInquiry.inquiryCode.replace(prefix, ''), 10);
      if (!isNaN(lastSeq)) {
        nextSeq = lastSeq + 1;
      }
    }

    return `${prefix}${nextSeq.toString().padStart(6, '0')}`;
  }
}
```

## 11. 前端入口文件 (apps/web/src/main.tsx)

```typescript
import React from 'react';
import ReactDOM from 'react-dom/client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { Toaster } from 'react-hot-toast';
import App from './App';
import './i18n';
import './index.css';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      staleTime: 5 * 60 * 1000,
    },
  },
});

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
      <Toaster position="top-right" />
    </QueryClientProvider>
  </React.StrictMode>
);
```

## 12. 应用路由 (apps/web/src/App.tsx)

```typescript
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import { useAuthStore } from './store/auth.store';

// Layouts
import PublicLayout from './components/layouts/PublicLayout';
import DashboardLayout from './components/layouts/DashboardLayout';

// Public pages
import Home from './pages/Home';
import Scan from './pages/Scan';
import DevicePublic from './pages/DevicePublic';
import ServiceRequest from './pages/ServiceRequest';
import Login from './pages/Login';

// Registration pages
import RegistrationTypeSelection from './pages/registration';
import CompanyRegistration from './pages/registration/CompanyRegistration';
import ExpertRegistration from './pages/registration/ExpertRegistration';

// Protected pages
import Dashboard from './pages/admin/Dashboard';
import PassportList from './pages/admin/PassportList';
import PassportCreate from './pages/admin/PassportCreate';
import PassportDetail from './pages/admin/PassportDetail';

// Marketplace pages
import MarketplaceHome from './pages/marketplace';
import ProductList from './pages/marketplace/ProductList';
import RFQList from './pages/marketplace/RFQList';

// Inquiry pages
import InquiryList from './pages/inquiries/InquiryList';
import InquiryDetail from './pages/inquiries/InquiryDetail';

function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const isAuthenticated = useAuthStore((state) => state.isAuthenticated);

  if (!isAuthenticated) {
    return <Navigate to="/login" replace />;
  }

  return <>{children}</>;
}

function App() {
  return (
    <BrowserRouter>
      <Routes>
        {/* Public routes */}
        <Route element={<PublicLayout />}>
          <Route path="/" element={<Home />} />
          <Route path="/scan" element={<Scan />} />
          <Route path="/scan/:code" element={<DevicePublic />} />
          <Route path="/service-request" element={<ServiceRequest />} />
          <Route path="/login" element={<Login />} />
          <Route path="/register" element={<RegistrationTypeSelection />} />
          <Route path="/register/company" element={<CompanyRegistration />} />
          <Route path="/register/expert" element={<ExpertRegistration />} />
        </Route>

        {/* Protected routes */}
        <Route
          element={
            <ProtectedRoute>
              <DashboardLayout />
            </ProtectedRoute>
          }
        >
          <Route path="/dashboard" element={<Dashboard />} />
          <Route path="/passports" element={<PassportList />} />
          <Route path="/passports/create" element={<PassportCreate />} />
          <Route path="/passports/:id" element={<PassportDetail />} />

          {/* Marketplace routes */}
          <Route path="/marketplace" element={<MarketplaceHome />} />
          <Route path="/marketplace/products" element={<ProductList />} />
          <Route path="/marketplace/rfqs" element={<RFQList />} />

          {/* Inquiry routes */}
          <Route path="/inquiries" element={<InquiryList />} />
          <Route path="/inquiries/:id" element={<InquiryDetail />} />
        </Route>

        {/* Fallback */}
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
    </BrowserRouter>
  );
}

export default App;
```

## 13. 认证状态管理 (apps/web/src/store/auth.store.ts)

```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import { User, UserRole } from '@device-passport/shared';

interface AuthState {
  user: Omit<User, 'password'> | null;
  accessToken: string | null;
  refreshToken: string | null;
  isAuthenticated: boolean;
  setAuth: (user: Omit<User, 'password'>, accessToken: string, refreshToken: string) => void;
  logout: () => void;
  hasRole: (roles: UserRole[]) => boolean;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      accessToken: null,
      refreshToken: null,
      isAuthenticated: false,

      setAuth: (user, accessToken, refreshToken) => {
        set({
          user,
          accessToken,
          refreshToken,
          isAuthenticated: true,
        });
      },

      logout: () => {
        set({
          user: null,
          accessToken: null,
          refreshToken: null,
          isAuthenticated: false,
        });
      },

      hasRole: (roles: UserRole[]) => {
        const user = get().user;
        if (!user) return false;

        const roleHierarchy: Record<UserRole, number> = {
          [UserRole.PUBLIC]: 0,
          [UserRole.CUSTOMER]: 1,
          [UserRole.ENGINEER]: 2,
          [UserRole.QC_INSPECTOR]: 3,
          [UserRole.OPERATOR]: 4,
          [UserRole.ADMIN]: 5,
        };

        const userLevel = roleHierarchy[user.role];
        const minRequired = Math.min(...roles.map((r) => roleHierarchy[r]));

        return userLevel >= minRequired;
      },
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({
        user: state.user,
        accessToken: state.accessToken,
        refreshToken: state.refreshToken,
        isAuthenticated: state.isAuthenticated,
      }),
    }
  )
);
```

## 14. API服务 (apps/web/src/services/api.ts)

```typescript
import axios from 'axios';
import { useAuthStore } from '../store/auth.store';

const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000';

export const api = axios.create({
  baseURL: `${API_URL}/api/v1`,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor to add auth token
api.interceptors.request.use(
  (config) => {
    const token = useAuthStore.getState().accessToken;
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor to handle errors
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      useAuthStore.getState().logout();
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

// Auth API
export const authApi = {
  login: async (email: string, password: string) => {
    const response = await api.post('/auth/login', { email, password });
    return response.data.data;
  },
  register: async (email: string, password: string, name: string) => {
    const response = await api.post('/auth/register', { email, password, name });
    return response.data.data;
  },
};

// Passport API
export const passportApi = {
  getAll: async (params?: Record<string, unknown>) => {
    const response = await api.get('/passports', { params });
    return response.data.data;
  },
  getById: async (id: string) => {
    const response = await api.get(`/passports/${id}`);
    return response.data.data;
  },
  create: async (data: Record<string, unknown>) => {
    const response = await api.post('/passports', data);
    return response.data.data;
  },
  updateStatus: async (id: string, data: { status: string; note?: string }) => {
    const response = await api.patch(`/passports/${id}/status`, data);
    return response.data.data;
  },
  getQRCode: async (id: string) => {
    const response = await api.get(`/passports/${id}/qrcode`);
    return response.data.data;
  },
};

// Marketplace Products API
export const marketplaceProductApi = {
  search: async (params?: Record<string, unknown>) => {
    const response = await api.get('/marketplace/products', { params });
    return response.data;
  },
  getById: async (id: string) => {
    const response = await api.get(`/marketplace/products/${id}`);
    return response.data;
  },
  create: async (data: Record<string, unknown>) => {
    const response = await api.post('/marketplace/products', data);
    return response.data;
  },
};

// Inquiry API
export const inquiryApi = {
  getAll: async () => {
    const response = await api.get('/inquiries');
    return response.data;
  },
  getById: async (id: string) => {
    const response = await api.get(`/inquiries/${id}`);
    return response.data;
  },
  create: async (data: Record<string, unknown>) => {
    const response = await api.post('/inquiries', data);
    return response.data;
  },
  sendMessage: async (id: string, data: Record<string, unknown>) => {
    const response = await api.post(`/inquiries/${id}/messages`, data);
    return response.data;
  },
};

// Matching API
export const matchingApi = {
  getRecommendations: async (role: 'supplier' | 'buyer', limit = 20) => {
    const response = await api.get('/matching/recommendations', {
      params: { role, limit },
    });
    return response.data;
  },
  dismissMatch: async (id: string) => {
    const response = await api.post(`/matching/recommendations/${id}/dismiss`);
    return response.data;
  },
};
```

## 15. 首页组件 (apps/web/src/pages/Home.tsx)

```typescript
import { Link } from 'react-router-dom';
import { QrCode, Shield, Clock, Wrench, ArrowRight } from 'lucide-react';
import { useTranslation } from 'react-i18next';

export default function Home() {
  const { t } = useTranslation();

  const features = [
    {
      icon: QrCode,
      title: t('home.feature1Title'),
      description: t('home.feature1Desc'),
    },
    {
      icon: Shield,
      title: t('home.feature2Title'),
      description: t('home.feature2Desc'),
    },
    {
      icon: Clock,
      title: t('home.feature3Title'),
      description: t('home.feature3Desc'),
    },
    {
      icon: Wrench,
      title: t('home.feature4Title'),
      description: t('home.feature4Desc'),
    },
  ];

  return (
    <div>
      {/* Hero Section */}
      <section className="bg-gradient-to-r from-primary-600 to-primary-800 text-white">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-24">
          <div className="text-center">
            <h1 className="text-4xl md:text-5xl font-bold mb-6">
              {t('home.heroTitle')}
            </h1>
            <p className="text-xl text-primary-100 max-w-2xl mx-auto mb-8">
              {t('home.heroSubtitle')}
            </p>
            <div className="flex justify-center space-x-4">
              <Link to="/scan" className="btn bg-white text-primary-600 hover:bg-gray-100 px-6 py-3">
                <QrCode className="h-5 w-5 mr-2" />
                {t('home.scanDevice')}
              </Link>
              <Link
                to="/service-request"
                className="btn bg-primary-500 text-white hover:bg-primary-400 px-6 py-3"
              >
                {t('home.requestService')}
              </Link>
            </div>
          </div>
        </div>
      </section>

      {/* Features Section */}
      <section className="py-20">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="text-center mb-16">
            <h2 className="text-3xl font-bold text-gray-900 mb-4">
              {t('home.featuresTitle')}
            </h2>
          </div>

          <div className="grid md:grid-cols-2 lg:grid-cols-4 gap-8">
            {features.map((feature) => (
              <div key={feature.title} className="card p-6 text-center">
                <div className="inline-flex items-center justify-center h-12 w-12 rounded-full bg-primary-100 text-primary-600 mb-4">
                  <feature.icon className="h-6 w-6" />
                </div>
                <h3 className="text-lg font-semibold text-gray-900 mb-2">{feature.title}</h3>
                <p className="text-gray-600">{feature.description}</p>
              </div>
            ))}
          </div>
        </div>
      </section>
    </div>
  );
}
```

## 16. 登录页面 (apps/web/src/pages/Login.tsx)

```typescript
import { useState } from 'react';
import { useNavigate, Link } from 'react-router-dom';
import { useForm } from 'react-hook-form';
import { LogIn, AlertCircle } from 'lucide-react';
import { authApi } from '../services/api';
import { useAuthStore } from '../store/auth.store';
import toast from 'react-hot-toast';

interface LoginForm {
  email: string;
  password: string;
}

export default function Login() {
  const navigate = useNavigate();
  const setAuth = useAuthStore((state) => state.setAuth);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<LoginForm>();

  const onSubmit = async (data: LoginForm) => {
    setIsLoading(true);
    setError(null);

    try {
      const response = await authApi.login(data.email, data.password);
      setAuth(response.user, response.accessToken, response.refreshToken);
      toast.success('Login successful!');
      navigate('/dashboard');
    } catch (err: unknown) {
      const error = err as { response?: { data?: { message?: string } } };
      setError(error.response?.data?.message || 'Invalid credentials');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-[80vh] flex items-center justify-center px-4">
      <div className="max-w-md w-full">
        <div className="text-center mb-8">
          <LogIn className="h-12 w-12 text-primary-600 mx-auto mb-4" />
          <h1 className="text-2xl font-bold text-gray-900">Sign in to your account</h1>
          <p className="text-gray-600 mt-2">
            Or{' '}
            <Link to="/register" className="text-primary-600 hover:text-primary-500">
              create a new account
            </Link>
          </p>
        </div>

        <form onSubmit={handleSubmit(onSubmit)} className="card p-6 space-y-4">
          {error && (
            <div className="flex items-center gap-2 p-3 bg-red-50 text-red-700 rounded-md">
              <AlertCircle className="h-5 w-5" />
              <span>{error}</span>
            </div>
          )}

          <div>
            <label className="label">Email</label>
            <input
              type="email"
              className="input"
              placeholder="you@example.com"
              {...register('email', {
                required: 'Email is required',
                pattern: { value: /^\S+@\S+$/i, message: 'Invalid email' },
              })}
            />
            {errors.email && (
              <p className="mt-1 text-sm text-red-600">{errors.email.message}</p>
            )}
          </div>

          <div>
            <label className="label">Password</label>
            <input
              type="password"
              className="input"
              placeholder="Enter your password"
              {...register('password', {
                required: 'Password is required',
                minLength: { value: 6, message: 'Password must be at least 6 characters' },
              })}
            />
            {errors.password && (
              <p className="mt-1 text-sm text-red-600">{errors.password.message}</p>
            )}
          </div>

          <button type="submit" disabled={isLoading} className="btn-primary w-full py-3">
            {isLoading ? 'Signing in...' : 'Sign in'}
          </button>
        </form>

        <div className="mt-6 card p-4 bg-gray-50">
          <h3 className="text-sm font-medium text-gray-900 mb-2">Demo Accounts:</h3>
          <div className="text-xs text-gray-600 space-y-1 font-mono">
            <p>admin@luna.top / password123 (Admin)</p>
            <p>operator@luna.top / password123 (Operator)</p>
          </div>
        </div>
      </div>
    </div>
  );
}
```

---

# 文档结束

**说明:** 本源代码文档包含了设备数字护照溯源管理系统的核心源代码，展示了系统的主要技术架构和实现方式。代码采用TypeScript语言编写，使用React和NestJS框架构建前后端分离架构。

**代码统计:**
- 后端代码: 约25,000行
- 前端代码: 约20,000行
- 共享代码: 约5,000行
- 总计: 约50,000行

**版权声明:** 本软件源代码版权归[您的公司名称]所有，未经授权不得复制、修改或分发。
